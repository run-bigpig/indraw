import React, { useState, useEffect, useRef } from 'react';
import { 
  Layers, 
  Image as ImageIcon, 
  Download, 
  MousePointer2, 
  Brush, 
  Square, 
  Circle as CircleIcon, 
  Star as StarIcon, 
  Undo, 
  RefreshCcw, 
  Loader2 
} from 'lucide-react';

// 椭圆图标小组件
const EllipseIcon = () => (
  <div className="w-4 h-3 rounded-full border-2 border-current" />
);

// 动态加载 Konva 脚本
const useScript = (src) => {
  const [status, setStatus] = useState(src ? 'loading' : 'idle');
  useEffect(() => {
    if (!src) {
      setStatus('idle');
      return;
    }
    let script = document.querySelector(`script[src="${src}"]`);
    if (!script) {
      script = document.createElement('script');
      script.src = src;
      script.async = true;
      script.setAttribute('data-status', 'loading');
      document.body.appendChild(script);
      const setAttributeFromEvent = (event) => {
        script.setAttribute('data-status', event.type === 'load' ? 'ready' : 'error');
      };
      script.addEventListener('load', setAttributeFromEvent);
      script.addEventListener('error', setAttributeFromEvent);
    } else {
      setStatus(script.getAttribute('data-status'));
    }
    const setStateFromEvent = (event) => {
      setStatus(event.type === 'load' ? 'ready' : 'error');
    };
    script.addEventListener('load', setStateFromEvent);
    script.addEventListener('error', setStateFromEvent);
    return () => {
      if (script) {
        script.removeEventListener('load', setStateFromEvent);
        script.removeEventListener('error', setStateFromEvent);
      }
    };
  }, [src]);
  return status;
};

export default function KonvaMaskApp() {
  // --- 状态管理 ---
  const [tool, setTool] = useState('brush'); 
  const [mode, setMode] = useState('destination-out'); 
  const [brushSize, setBrushSize] = useState(30);
  const [isLoading, setIsLoading] = useState(true);
  const [statusText, setStatusText] = useState('初始化引擎...');

  // --- Refs ---
  const containerRef = useRef(null);
  const stageRef = useRef(null);
  const layerRef = useRef(null);
  const mainGroupRef = useRef(null);
  const imageNodeRef = useRef(null);
  
  // 分组 Refs
  const eraserGroupRef = useRef(null);
  const clipGroupRef = useRef(null);
  
  const transformerRef = useRef(null);
  
  // 交互 Refs
  const isDrawingRef = useRef(false);
  const currentShapeRef = useRef(null);
  const startPosRef = useRef({ x: 0, y: 0 });

  // 状态同步 Refs
  const toolRef = useRef(tool);
  const modeRef = useRef(mode);
  const brushSizeRef = useRef(brushSize);

  const konvaStatus = useScript('https://unpkg.com/konva@9.3.3/konva.min.js');

  // --- 初始化 ---
  useEffect(() => {
    if (konvaStatus === 'ready' && containerRef.current && !stageRef.current) {
      initKonva();
    }
  }, [konvaStatus]);

  // --- 监听模式/工具变化 ---
  useEffect(() => {
    toolRef.current = tool;
    modeRef.current = mode;
    brushSizeRef.current = brushSize;

    if (stageRef.current) {
        stageRef.current.container().style.cursor = tool === 'select' ? 'default' : 'crosshair';

        // 切换非选择工具时，清空选中
        if (tool !== 'select' && transformerRef.current) {
            transformerRef.current.nodes([]);
            updateShapesDraggable(false);
        } else if (tool === 'select') {
            updateShapesDraggable(true);
        }
    }

    // 选中图形的组迁移逻辑
    if (transformerRef.current && transformerRef.current.nodes().length > 0) {
        const node = transformerRef.current.nodes()[0];
        const currentParent = node.getParent();
        let targetGroup = null;

        if (mode === 'destination-out') {
            targetGroup = eraserGroupRef.current;
        } else {
            targetGroup = clipGroupRef.current;
        }

        if (currentParent !== targetGroup && targetGroup) {
            node.moveTo(targetGroup);
            node.globalCompositeOperation('source-over'); 
            
            // 移动后需要更新缓存
            updateClipGroupCache();
            layerRef.current.batchDraw();
        }
    }

  }, [mode, tool, brushSize]);

  // --- 核心修复：更新 ClipGroup 的缓存 ---
  // 这是解决“主体空白”问题的关键：将所有保留形状合并为一个 Mask
  const updateClipGroupCache = () => {
    const group = clipGroupRef.current;
    if (!group || !stageRef.current) return;
    
    // 必须清除旧缓存，否则画面不会更新
    group.clearCache();
    
    const childrenCount = group.getChildren().length;
    
    // 如果没有保留形状，隐藏组（不进行裁剪，显示原图）
    // 注意：如果您的逻辑是“没有任何形状时全黑”，可以改为 visible(true) 但不添加形状
    // 这里采用“无裁剪=显示全图”的逻辑
    if (childrenCount === 0) {
        group.visible(false);
        return;
    }
    
    group.visible(true);
    
    // 缓存整个舞台区域
    // 这样 destination-in 才能正确作用于整张图
    try {
        group.cache({
            x: 0,
            y: 0,
            width: stageRef.current.width(),
            height: stageRef.current.height(),
            pixelRatio: 1 // 保持 1 以获得最佳性能，高分屏可设为 window.devicePixelRatio
        });
    } catch (e) {
        console.warn("Cache failed", e);
    }
  };

  const initKonva = () => {
    if (!window.Konva) return;

    const width = containerRef.current.clientWidth;
    const height = containerRef.current.clientHeight;

    const stage = new window.Konva.Stage({
      container: containerRef.current,
      width: width,
      height: height,
    });
    stageRef.current = stage;

    const layer = new window.Konva.Layer();
    stage.add(layer);
    layerRef.current = layer;

    const mainGroup = new window.Konva.Group();
    layer.add(mainGroup);
    mainGroupRef.current = mainGroup;

    // 1. 橡皮擦组 (自动叠加挖空，不需要 cache)
    const eraserGroup = new window.Konva.Group({
        globalCompositeOperation: 'destination-out' 
    });
    mainGroup.add(eraserGroup);
    eraserGroupRef.current = eraserGroup;

    // 2. 裁剪组 (自动合并保留，必须 cache)
    const clipGroup = new window.Konva.Group({
        globalCompositeOperation: 'destination-in',
        visible: false 
    });
    mainGroup.add(clipGroup);
    clipGroupRef.current = clipGroup;

    const tr = new window.Konva.Transformer({
      nodes: [],
      centeredScaling: false,
      rotationSnaps: [0, 90, 180, 270],
      borderStroke: '#3b82f6',
      anchorStroke: '#3b82f6',
      anchorFill: '#ffffff',
      anchorSize: 10,
    });
    // 监听 Transformer 的变化，实时更新缓存
    tr.on('transform dragmove', () => {
        // 如果正在操作 ClipGroup 内的物体，需要刷新缓存
        if (tr.nodes().length > 0 && tr.nodes()[0].getParent() === clipGroupRef.current) {
            updateClipGroupCache();
        }
    });
    layer.add(tr);
    transformerRef.current = tr;

    stage.on('mousedown touchstart', handleMouseDown);
    stage.on('mousemove touchmove', handleMouseMove);
    stage.on('mouseup touchend', handleMouseUp);

    loadImage("https://images.unsplash.com/photo-1542202229-7d93c33f5d07?q=80&w=1000&auto=format&fit=crop");

    const resizeObserver = new ResizeObserver(() => {
        if (containerRef.current && stageRef.current) {
            const w = containerRef.current.clientWidth;
            const h = containerRef.current.clientHeight;
            stageRef.current.width(w);
            stageRef.current.height(h);
            
            // 窗口大小改变，需要刷新缓存大小
            updateClipGroupCache();
            stageRef.current.batchDraw();
        }
    });
    resizeObserver.observe(containerRef.current);
  };

  const loadImage = (src) => {
    setIsLoading(true);
    setStatusText("加载图片中...");
    const img = new Image();
    img.crossOrigin = "Anonymous";
    img.src = src;
    img.onload = () => {
      renderImage(img);
      setIsLoading(false);
      setStatusText("就绪");
    };
    img.onerror = () => {
      setIsLoading(false);
      setStatusText("图片加载失败");
    };
  };

  const renderImage = (imgObj) => {
    if (!window.Konva || !mainGroupRef.current) return;
    
    if (imageNodeRef.current) imageNodeRef.current.destroy();
    eraserGroupRef.current.destroyChildren();
    clipGroupRef.current.destroyChildren();
    
    // 清除旧缓存
    clipGroupRef.current.clearCache();
    clipGroupRef.current.visible(false);

    transformerRef.current.nodes([]);

    const stage = stageRef.current;
    const padding = 40;
    const scale = Math.min(
      (stage.width() - padding) / imgObj.width, 
      (stage.height() - padding) / imgObj.height
    );

    const w = imgObj.width * scale;
    const h = imgObj.height * scale;
    const x = (stage.width() - w) / 2;
    const y = (stage.height() - h) / 2;

    const konvaImage = new window.Konva.Image({
      image: imgObj,
      x: x,
      y: y,
      width: w,
      height: h,
      listening: true
    });

    mainGroupRef.current.add(konvaImage);
    konvaImage.moveToBottom();
    imageNodeRef.current = konvaImage;
    
    layerRef.current.batchDraw();
  };

  const updateShapesDraggable = (draggable) => {
      [eraserGroupRef.current, clipGroupRef.current].forEach(group => {
          if (group) {
              group.getChildren().forEach(node => node.draggable(draggable));
          }
      });
  };

  const handleMouseDown = (e) => {
    const stage = stageRef.current;
    if (!stage) return;

    const currentTool = toolRef.current;
    const currentMode = modeRef.current;
    
    // 1. 选择工具
    if (currentTool === 'select') {
        const target = e.target;
        if (target === stage || target === imageNodeRef.current) {
            transformerRef.current.nodes([]);
            layerRef.current.batchDraw();
            return;
        }
        
        const parent = target.getParent();
        if (parent === eraserGroupRef.current || parent === clipGroupRef.current) {
            transformerRef.current.nodes([target]);
            
            if (parent === eraserGroupRef.current && modeRef.current !== 'destination-out') {
                setMode('destination-out');
            } else if (parent === clipGroupRef.current && modeRef.current !== 'destination-in') {
                setMode('destination-in');
            }
            layerRef.current.batchDraw();
        }
        return;
    }

    // 2. 绘图
    transformerRef.current.nodes([]); 
    isDrawingRef.current = true;
    const pos = stage.getPointerPosition();
    startPosRef.current = { x: pos.x, y: pos.y };
    
    let targetGroup = currentMode === 'destination-out' ? eraserGroupRef.current : clipGroupRef.current;

    // 形状属性：在组内叠加 (source-over)，组本身负责裁剪
    const commonProps = {
        globalCompositeOperation: 'source-over', 
        stroke: 'black', 
        fill: 'black', 
        draggable: false
    };

    if (currentTool === 'brush') {
        currentShapeRef.current = new window.Konva.Line({
            ...commonProps,
            strokeWidth: brushSizeRef.current,
            lineCap: 'round',
            lineJoin: 'round',
            points: [pos.x, pos.y],
            tension: 0.5,
            fill: null // 画笔通常是空心的
        });
    } else {
        const shapeProps = { ...commonProps, x: pos.x, y: pos.y };
        if (currentTool === 'rect') {
            currentShapeRef.current = new window.Konva.Rect({ ...shapeProps, width: 0, height: 0 });
        } else if (currentTool === 'circle') {
            currentShapeRef.current = new window.Konva.Circle({ ...shapeProps, radius: 0 });
        } else if (currentTool === 'ellipse') {
            currentShapeRef.current = new window.Konva.Ellipse({ ...shapeProps, radiusX: 0, radiusY: 0 });
        } else if (currentTool === 'star') {
            currentShapeRef.current = new window.Konva.Star({ 
                ...shapeProps, numPoints: 5, innerRadius: 0, outerRadius: 0, rotation: 180 
            });
        }
    }

    if (currentShapeRef.current) {
        targetGroup.add(currentShapeRef.current);
        // 如果是裁剪组，添加新物体后立即更新缓存，否则看不到
        if (targetGroup === clipGroupRef.current) {
            updateClipGroupCache();
        }
        layerRef.current.batchDraw();
    }
  };

  const handleMouseMove = (e) => {
    if (!isDrawingRef.current || !currentShapeRef.current) return;
    e.evt.preventDefault();

    const stage = stageRef.current;
    const pos = stage.getPointerPosition();
    const currentTool = toolRef.current;
    const shape = currentShapeRef.current;

    if (currentTool === 'brush') {
        const newPoints = shape.points().concat([pos.x, pos.y]);
        shape.points(newPoints);
    } else {
        const start = startPosRef.current;
        const dx = pos.x - start.x;
        const dy = pos.y - start.y;

        if (currentTool === 'rect') {
            shape.width(dx);
            shape.height(dy);
        } else if (currentTool === 'circle') {
            const r = Math.sqrt(dx*dx + dy*dy);
            shape.radius(r);
        } else if (currentTool === 'ellipse') {
            shape.radiusX(Math.abs(dx));
            shape.radiusY(Math.abs(dy));
        } else if (currentTool === 'star') {
            const r = Math.sqrt(dx*dx + dy*dy);
            shape.outerRadius(r);
            shape.innerRadius(r / 2);
        }
    }

    // 拖动过程中持续更新缓存，虽然耗费性能，但必须这样做才能看到实时裁剪效果
    if (shape.getParent() === clipGroupRef.current) {
        updateClipGroupCache();
    }
    
    layerRef.current.batchDraw();
  };

  const handleMouseUp = () => {
    isDrawingRef.current = false;
    currentShapeRef.current = null;
    // 结束时确保缓存最新
    updateClipGroupCache();
    layerRef.current.batchDraw();
  };

  const handleUndo = () => {
      const group = modeRef.current === 'destination-out' ? eraserGroupRef.current : clipGroupRef.current;
      if (group && group.getChildren().length > 0) {
           const children = group.getChildren();
           const lastNode = children[children.length - 1];
           if (transformerRef.current.nodes().includes(lastNode)) {
               transformerRef.current.nodes([]);
           }
           lastNode.destroy();
           updateClipGroupCache(); // 撤销后更新缓存
           layerRef.current.batchDraw();
      }
  };

  const handleReset = () => {
      eraserGroupRef.current.destroyChildren();
      clipGroupRef.current.destroyChildren();
      transformerRef.current.nodes([]);
      updateClipGroupCache(); // 重置后更新
      layerRef.current.batchDraw();
  };

  const handleExport = () => {
      if (!stageRef.current) return;
      const nodes = transformerRef.current.nodes();
      transformerRef.current.nodes([]);
      
      const uri = stageRef.current.toDataURL({ pixelRatio: 2 });
      
      transformerRef.current.nodes(nodes);

      const link = document.createElement('a');
      link.download = `mask-export-${Date.now()}.png`;
      link.href = uri;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
  };

  const handleFileChange = (e) => {
      const file = e.target.files[0];
      if (file) {
          const reader = new FileReader();
          reader.onload = (evt) => loadImage(evt.target.result);
          reader.readAsDataURL(file);
      }
  };

  const ToolButton = ({ t, icon: Icon, label }) => (
    <button
      onClick={() => setTool(t)}
      className={`p-2 rounded transition-colors flex items-center justify-center ${
        tool === t 
          ? 'bg-blue-600 text-white border-blue-500 shadow-inner' 
          : 'text-gray-400 hover:bg-gray-700 hover:text-white'
      }`}
      title={label}
    >
      <Icon size={20} />
    </button>
  );

  return (
    <div className="flex flex-col h-screen bg-gray-900 text-white font-sans overflow-hidden">
      <header className="flex flex-col gap-2 px-6 py-3 bg-gray-800 border-b border-gray-700 shadow-lg z-10 shrink-0">
        <div className="flex items-center justify-between">
          <div className="flex items-center space-x-3">
            <div className="p-2 bg-gradient-to-br from-blue-600 to-indigo-600 rounded-lg shadow">
              <Layers className="w-6 h-6 text-white" />
            </div>
            <div>
              <h1 className="text-xl font-bold tracking-wide">React Mask Studio</h1>
              <p className="text-xs text-gray-400">专业图层蒙版工具 (Cached Groups)</p>
            </div>
          </div>

          <div className="flex items-center space-x-3">
             <label className="flex items-center px-3 py-1.5 bg-gray-700 hover:bg-gray-600 text-sm text-white rounded cursor-pointer transition-all border border-gray-600 shadow-sm">
                <ImageIcon size={16} className="mr-2" />
                <span>换图</span>
                <input type="file" accept="image/*" onChange={handleFileChange} className="hidden" />
            </label>
            <button 
              onClick={handleExport}
              className="flex items-center px-3 py-1.5 bg-green-600 hover:bg-green-500 text-sm text-white rounded font-medium transition-all shadow-sm active:scale-95"
            >
              <Download size={16} className="mr-2" />
              <span>导出</span>
            </button>
          </div>
        </div>

        <div className="flex items-center justify-between mt-2 pt-2 border-t border-gray-700">
           <div className="flex items-center space-x-1 bg-gray-900 p-1 rounded-lg border border-gray-700">
              <ToolButton t="select" icon={MousePointer2} label="选择/移动工具" />
              <div className="w-px h-6 bg-gray-700 mx-2"></div>
              <ToolButton t="brush" icon={Brush} label="画笔" />
              <ToolButton t="rect" icon={Square} label="矩形" />
              <ToolButton t="circle" icon={CircleIcon} label="圆形" />
              <ToolButton t="ellipse" icon={EllipseIcon} label="椭圆" />
              <ToolButton t="star" icon={StarIcon} label="五角星" />
           </div>

           <div className="flex items-center space-x-4">
              <div className="flex items-center space-x-2 bg-gray-700 px-3 py-1.5 rounded-lg border border-gray-600">
                  <span className="text-xs text-gray-400 uppercase font-bold tracking-wider">模式</span>
                  <select 
                    value={mode}
                    onChange={(e) => setMode(e.target.value)}
                    className="bg-gray-900 text-white text-sm border-none rounded px-2 py-1 focus:ring-1 focus:ring-blue-500 outline-none cursor-pointer"
                  >
                      <option value="destination-out">擦除 (挖空)</option>
                      <option value="destination-in">裁剪 (保留形状)</option>
                  </select>
              </div>

              {tool === 'brush' && (
                <div className="flex items-center space-x-2 bg-gray-700 px-3 py-1.5 rounded-lg border border-gray-600">
                    <span className="text-xs text-gray-400">笔触</span>
                    <input 
                      type="range" 
                      min="5" max="150" 
                      value={brushSize} 
                      onChange={(e) => setBrushSize(parseInt(e.target.value))}
                      className="w-24 h-1 bg-gray-500 rounded-lg appearance-none cursor-pointer accent-blue-500"
                    />
                    <span className="text-xs w-8 text-right font-mono">{brushSize}</span>
                </div>
              )}

              <div className="flex space-x-1 border-l border-gray-600 pl-4">
                  <button onClick={handleUndo} className="p-1.5 text-gray-400 hover:text-white hover:bg-gray-700 rounded transition" title="撤销上一步">
                      <Undo size={18} />
                  </button>
                  <button onClick={handleReset} className="p-1.5 text-gray-400 hover:text-white hover:bg-gray-700 rounded transition" title="重置画布">
                      <RefreshCcw size={18} />
                  </button>
              </div>
           </div>
        </div>
      </header>

      <main className="flex-1 relative overflow-hidden bg-[#0f1115] flex justify-center items-center p-6">
        <div className="relative w-full h-full rounded-xl shadow-2xl overflow-hidden border border-gray-700 bg-[#1a1a1a]"
             style={{
                backgroundImage: `
                  linear-gradient(45deg, #252525 25%, transparent 25%), 
                  linear-gradient(-45deg, #252525 25%, transparent 25%), 
                  linear-gradient(45deg, transparent 75%, #252525 75%), 
                  linear-gradient(-45deg, transparent 75%, #252525 75%)
                `,
                backgroundSize: '20px 20px',
                backgroundPosition: '0 0, 0 10px, 10px -10px, -10px 0px'
             }}
        >
            {isLoading && (
                <div className="absolute inset-0 flex flex-col items-center justify-center text-gray-400 bg-black/50 z-50 backdrop-blur-sm">
                    <Loader2 className="w-10 h-10 mb-3 animate-spin text-blue-500" />
                    <p className="font-medium tracking-wide">{statusText}</p>
                </div>
            )}
            
            <div ref={containerRef} className="w-full h-full" />
        </div>
      </main>

      <footer className="px-6 py-2 bg-gray-800 border-t border-gray-700 text-xs text-gray-400 flex justify-between shrink-0 select-none">
        <div className="flex space-x-6">
          <span>当前工具: <strong className="text-blue-400 uppercase">{tool}</strong></span>
          <span>混合模式: <strong className={mode === 'destination-out' ? 'text-red-400' : 'text-green-400'}>
              {mode === 'destination-out' ? 'ERASE (擦除)' : 'CLIP (保留形状)'}
          </strong></span>
        </div>
        <div className="opacity-70">
          {tool === 'select' 
            ? '提示: 移动图形可调整裁剪/擦除区域。改变上方模式可实时生效。' 
            : '提示: 使用矩形/圆形/五角星可获得实心裁剪。画笔是空心的。'}
        </div>
      </footer>
    </div>
  );
}